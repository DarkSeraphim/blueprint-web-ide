{"version":3,"file":"App.svelte","sources":["App.svelte"],"sourcesContent":["<script context=\"module\">import * as BaseDefinitions from \"./definitions\";\nimport * as LanguageDefinitions from \"./languages\";\nimport { RegisterTileDefinition } from \"./models/TileDefinition\";\nimport { RegisterLanguageTileDefinition } from \"./models/LanguageTileDefinition\";\nObject.values(BaseDefinitions).forEach((definition) => {\n    RegisterTileDefinition(definition);\n});\nObject.entries(LanguageDefinitions).forEach(([language, definitions]) => {\n    Object.values(definitions).forEach((definition) => {\n        RegisterLanguageTileDefinition(language, definition);\n    });\n});\n</script>\n\n<script lang=\"ts\">import Draggable from \"./components/Draggable.svelte\";\nimport DrawingConnection from \"./components/DrawingConnection.svelte\";\nimport Connection from \"./components/Connection.svelte\";\n;\n;\n;\n;\n;\nimport { GenerateGUID } from \"./utils/random\";\nimport { GetTileDefinition } from \"./models/TileDefinition\";\nimport { tiles, connections, drawnConnection } from \"@ide/store\";\nimport { derived, get, writable } from \"svelte/store\";\nimport { Compile } from \"./engine/transpiler\";\nimport { onMount } from \"svelte\";\nimport Panzoom from \"@panzoom/panzoom\";\nimport ButtonWheel from \"./components/ButtonWheel.svelte\";\nlet compiled = \"\";\nlet self;\n// TODO Global Point Size\nconst pointOffsetX = 8;\nconst pointOffsetY = 10;\nlet panzoom;\nlet panScale = 0;\nlet panX = 0;\nlet panY = 0;\nlet contextClick;\nonMount(() => {\n    panzoom = Panzoom(self, {\n        maxScale: 2,\n        contain: \"outside\",\n        setTransform: (elem, { scale, x, y }) => {\n            panScale = scale;\n            panX = x;\n            panY = y;\n            panzoom.setStyle(\"transform\", `scale(${scale}) translate(${x}px, ${y}px)`);\n        },\n    });\n    parent.addEventListener(\"wheel\", panzoom.zoomWithWheel);\n});\nconst generateTile = () => {\n    return {\n        definition: GetTileDefinition(\"Sum\"),\n        metadata: {\n            id: GenerateGUID(),\n            position: {\n                x: document.documentElement.clientWidth / 2,\n                y: document.documentElement.clientHeight / 2,\n            },\n        },\n    };\n};\nconst validConnecton = derived(drawnConnection, ($drawnConnection) => {\n    return $drawnConnection;\n});\nconst calculateBounds = (connection) => {\n    const conn = get(connection);\n    if (!conn || !conn.sourceTile || !conn.targetTile) {\n        return writable({\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            swap: false,\n        });\n    }\n    return derived([conn.sourceTile.tile, conn.targetTile.tile], ([sourceTile, targetTile]) => {\n        let left = Number.MAX_SAFE_INTEGER;\n        let right = 0;\n        let top = Number.MAX_SAFE_INTEGER;\n        let bottom = 0;\n        const sourceBounds = sourceTile.metadata.pinComponents[conn.sourceTile.pin.name].getBoundingClientRect();\n        const targetBounds = targetTile.metadata.pinComponents[conn.targetTile.pin.name].getBoundingClientRect();\n        left = Math.min(left, sourceBounds.x);\n        right = Math.max(right, sourceBounds.x);\n        top = Math.min(top, sourceBounds.y);\n        bottom = Math.max(bottom, sourceBounds.y);\n        left = Math.min(left, targetBounds.x);\n        right = Math.max(right, targetBounds.x);\n        top = Math.min(top, targetBounds.y);\n        bottom = Math.max(bottom, targetBounds.y);\n        const swap = !((left !== targetBounds.x && top !== targetBounds.y) ||\n            (right !== targetBounds.x && bottom !== targetBounds.y));\n        top -= pointOffsetY - 4;\n        const containerBB = self.getBoundingClientRect();\n        left -= containerBB.x;\n        right -= containerBB.x;\n        top -= containerBB.y;\n        bottom -= containerBB.y;\n        left /= panScale;\n        right /= panScale;\n        top /= panScale;\n        bottom /= panScale;\n        // TODO Fix zoom scaling for point offsets\n        left += pointOffsetX;\n        right += pointOffsetX;\n        top += pointOffsetY;\n        bottom += pointOffsetY;\n        return {\n            x: left,\n            y: top,\n            width: right - left,\n            height: bottom - top,\n            swap,\n        };\n    });\n};\nconst onRightClick = (event) => {\n    event.preventDefault();\n    let current = event.target;\n    while (current && !(\"ide_component\" in current)) {\n        current = current.parentElement;\n    }\n    if (!current) {\n        contextClick = undefined;\n    }\n    else {\n        contextClick = {\n            pageX: event.pageX,\n            pageY: event.pageY,\n            offsetX: event.offsetX,\n            offsetY: event.offsetY,\n            context: current.ide_component,\n        };\n    }\n};\n</script>\n\n<style>\n  :global(body) {\n    margin: 0;\n    background: rgb(36, 36, 36);\n    color: white;\n    font-family: \"Roboto\", sans-serif;\n  }\n\n  .App {\n    width: 100vw;\n    height: 100vh;\n  }\n\n  .HUD {\n    position: absolute;\n    z-index: 9999999999;\n  }\n\n  .Container {\n    width: 16000px;\n    height: 9000px;\n    outline: 3px solid rgb(156 156 156);\n    background: repeating-linear-gradient(\n        00deg,\n        rgba(0 0 0 / 0%),\n        rgba(0 0 0 / 0) 39px,\n        rgb(55, 55, 55) 0,\n        rgb(55, 55, 55) 40px\n      ),\n      repeating-linear-gradient(\n        90deg,\n        rgba(0 0 0 / 0%),\n        rgba(0 0 0 / 0) 39px,\n        rgb(55, 55, 55) 0,\n        rgb(55, 55, 55) 40px\n      );\n  }\n</style>\n\n<div class=\"App\" style=\"background-position: {panX}px {panY}px\">\n  <div class=\"HUD\">\n    <button on:click={() => tiles.add(generateTile())}>Add Draggable</button>\n    <button on:click={() => (compiled = Compile())}>Compile</button>\n    <button on:click={() => panzoom.zoom(0.9)}>0.90</button>\n    <br /> Total Draggables: {Object.values($tiles).length}\n    <br /> Scale: {panScale}\n    <br /> X: {panX}\n    <br /> Y: {panY}\n    <br />\n    <textarea cols=\"100\" rows=\"10\">{compiled}</textarea>\n  </div>\n\n  {#if contextClick}\n    <ButtonWheel point={contextClick} />\n  {/if}\n\n  <div class=\"Container\" bind:this={self} on:contextmenu={onRightClick}>\n    {#if $drawnConnection}\n      <DrawingConnection\n        connection={validConnecton}\n        offsetBB={self.getBoundingClientRect()}\n        scaling={panScale} />\n    {/if}\n\n    {#each Object.values($tiles) as tile}\n      <Draggable {tile} scaling={panScale} offsetX={panX} offsetY={panY} />\n    {/each}\n\n    {#each Object.values($connections) as connection}\n      <Connection bounds={calculateBounds(connection)} />\n    {/each}\n  </div>\n</div>\n"],"names":[],"mappings":"AA8IU,IAAI,AAAE,CAAC,AACb,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAC3B,KAAK,CAAE,KAAK,CACZ,WAAW,CAAE,QAAQ,CAAC,CAAC,UAAU,AACnC,CAAC,AAED,IAAI,eAAC,CAAC,AACJ,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,AACf,CAAC,AAED,IAAI,eAAC,CAAC,AACJ,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,UAAU,AACrB,CAAC,AAED,UAAU,eAAC,CAAC,AACV,KAAK,CAAE,OAAO,CACd,MAAM,CAAE,MAAM,CACd,OAAO,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CACnC,UAAU,CAAE;QACR,KAAK,CAAC;QACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QACjB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACrB,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAClB,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI;OACrB,CAAC;MACF;QACE,KAAK,CAAC;QACN,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QACjB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACrB,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAClB,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI;OACrB,AACL,CAAC"}